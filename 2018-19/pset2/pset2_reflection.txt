                                    ________________________________________________________
                                    /  ____________________________________________________  \
                                    | |<_> <_> <_> <_> <_> <_> <_> <_> <_> <_> <_> <_> <_> | |
                                    | |<_> <_> <_> <_> <_> <_> <_> <_> <_> <_> <_> <_> <_> | |
                                    | |_|___|___|___|___|___|___|___|___|___|___|___|___|__| |
                                    |  ____________________________________________________  |
                                    | | |   |   |   |   |   |   |   |   |   |   |   |   |  | |
                                    | |<_> <_> <_> <_> <_> <_> <_> <_> <_> <_> <_> <_> <_> | |
                                    | |<_> <_> <_> <_> <_> <_> <_> <_> <_> <_> <_> <_> <_> | |
                                    | |<_> <_> <_> <_> <_> <_> <_> <_> <_> <_> <_> <_> <_> | |
                                    | |<_> <_> <_> <_> <_> <_> <_> <_> <_> <_> <_> <_> <_> | |
                                    | |<_>_<_>_<_>_<_>_<_>_<_>_<_>_<_>_<_>_<_>_<_>_<_>_<_>_| |
                                    \________________________________________________________/

    Tahmidul Alam
    PSET2 Reflection
    October 8th, 2018

    In the making of the vigenere cipher, I had to first create the caesar cipher. These ciphers encrypt a text based on the user input followed by only numbers (caesar) or only letters (vigenere). After I created a caesar cipher, all that was left was modifying the code and adapting the cipher into vigenere. The steps are as follows:

    1. First I put my C headers at the top of the code.
    2. I created my main function and passed arguments of int argc, and string argv[]
        a. argc = Argument count; How many arguments are in my CLI, command line input.
        b. argv[] = Argument vector; What input is the user typing in addition to running the program
    3. If argc was not 2, that means the user probably typed in something invalid.
        a. argc must be 2 because the argv[0] must be ./vigenere and argv[1] has to be the user inputting the key they want to
        encrypt. These are the 2 arguments that must be matched.
    4. I created a custom function called vigenere_key_check() and passed in an argument of argv[1] to check if the user correctly inputted a valid encryption key.
        a. If the user did not input a valid encryption key, the function would return a false.
        b. This function has a type of bool which means that the function will return a true/false. With the argument of argv[1],
        I used a for loop to check if any of the characters of the user input through CLI are alphanumeric (if it's a letter). If
        the input is not a letter, then I return false.
        c. In my main function, if the function returns false, then my if statement would become true and return 1.
            - This means that the user input has an invalid input in CLI.
    5. Back to my main function. Assuming the user's input was valid, I now ask the user to input a "plaintext". In other words,
    the text the user wants to encrypt.
        a. The CLI was the "key" the user wants to encrypt.
    6. Then, I get my key from argv[1], and store it in input_key (for logical reasons).
    7. Next, I want to find out how long the "key" is. I used strlen() and passed in an argument of input_key to determine the length of the key.
    8. Now that I got the user's text and the "key" he/she wants to encrypt it with, I am now ready to create the vigenere cipher.
    9. The vigenere cipher is stored under my custom function vigenere() that takes in the parameters of input, input_key, and len_key.
        a. input_code, input_key, input_key_strlen respectively.
    10. Inside the function, I print out "ciphertext: " based on the usage first.
    11. Next, I use a for loop to iterate through the user's input (aka "plaintext"), and start converting the letters based on the "key".
        a. The "key" is getting stored under code_key with a variable type int to change the letters based on its numeric position.
            - A = 1, B = 2, etc.
            - a = 1, b = 2, etc.
        b. The letter gets converted to a lowercase and gets subtracted from the ascii value of 'a'.
        c. The challenging part about creating the key was understanding how the key works. To overcome this challenge, under the program speculation, it shows how to convert the key into numbers. The user input's individual characters gets dialed up based on the key. So if the user's plaintext was HELLO, and the user wanted to encrypt HELLO with ABCAB, this is the same as saying encrypting HELLO with moving H 0 letter ahead, E 1 letters ahead, L 2 letters ahead, L 0 letter ahead, and O 1 letters ahead. The resulting output would be HFNLP.
        d. Based on the example above, it looks like we are getting the ascii key of the character and subtracting it from the lowercase character to get a numeric value. Then I use this value to dial up the letters. This solves my cipher issue.
    12. Now, I use a if statement to check for uppercase letters. If the plaintext has an uppercase, I take the key, convert it, and make the letter uppercase.
    13. I use a else if to check if the plaintext was lowercase.
        a. If the letter is lowercase, I take that character in plaintext and encrypt it with the "key" and then convert is back to a lowercase.
    14. Else, I just print out the character as it is.
    15. After the loop is done, this void function does not have a return. However, since I am calling this function on my main function, the result gets printed at the moment the vigenere() executes.
    16. For clarity, I printed out a enter with \n.
    17. After my code succeeds, I return 0. This tells the computer that the code launched succesfully.

    This is how Vigenere was made.